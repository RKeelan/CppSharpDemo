// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

namespace CppLib
{
    public unsafe partial class CppData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 64)]
        public partial struct __Internal
        {
            internal byte pub_bool;
            internal sbyte pub_i8;
            internal short pub_i16;
            internal int pub_i32;
            internal long pub_i64;
            internal float pub_f32;
            internal double pub_f64;
            internal byte prv_bool;
            internal sbyte prv_i8;
            internal short prv_i16;
            internal int prv_i32;
            internal long prv_i64;
            internal float prv_f32;
            internal double prv_f64;

            [SuppressUnmanagedCodeSecurity, DllImport("Cpp", EntryPoint = "??0CppData@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("CppLib", EntryPoint = "??0CppData@@QEAA@AEBV0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("Cpp", EntryPoint = "?GetBool@CppData@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetBool(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cpp", EntryPoint = "?SetBool@CppData@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetBool(__IntPtr __instance, bool value);

            [SuppressUnmanagedCodeSecurity, DllImport("CppLib", EntryPoint = "?GetInt8@CppData@@QEAACXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern sbyte GetInt8(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("CppLib", EntryPoint = "?SetInt8@CppData@@QEAAXC@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetInt8(__IntPtr __instance, sbyte value);

            [SuppressUnmanagedCodeSecurity, DllImport("Cpp", EntryPoint = "?GetInt16@CppData@@QEAAFXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern short GetInt16(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cpp", EntryPoint = "?SetInt16@CppData@@QEAAXF@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetInt16(__IntPtr __instance, short value);

            [SuppressUnmanagedCodeSecurity, DllImport("Cpp", EntryPoint = "?GetInt32@CppData@@QEAAHXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetInt32(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cpp", EntryPoint = "?SetInt32@CppData@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetInt32(__IntPtr __instance, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("Cpp", EntryPoint = "?GetInt64@CppData@@QEAA_JXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern long GetInt64(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cpp", EntryPoint = "?SetInt64@CppData@@QEAAX_J@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetInt64(__IntPtr __instance, long value);

            [SuppressUnmanagedCodeSecurity, DllImport("Cpp", EntryPoint = "?GetFloat@CppData@@QEAAMXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float GetFloat(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cpp", EntryPoint = "?SetFloat@CppData@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetFloat(__IntPtr __instance, float value);

            [SuppressUnmanagedCodeSecurity, DllImport("Cpp", EntryPoint = "?GetDouble@CppData@@QEAANXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern double GetDouble(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cpp", EntryPoint = "?SetDouble@CppData@@QEAAXN@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetDouble(__IntPtr __instance, double value);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppLib.CppData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppLib.CppData>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::CppLib.CppData managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::CppLib.CppData managed)
        {
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CppData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new CppData(native.ToPointer(), skipVTables);
        }

        internal static CppData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CppData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CppData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CppData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CppData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CppData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public CppData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CppLib.CppData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            __Internal.ctor(__Instance);
        }

        public CppData(global::CppLib.CppData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CppLib.CppData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::CppLib.CppData.__Internal*) __Instance) = *((global::CppLib.CppData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public static int Counter
        {
            get
            {
                var __ptr = (int*)global::CppLib.__Symbols.CppLib._Counter_CppData__2HA;
                return *__ptr;
            }

            set
            {
                var __ptr = (int*)global::CppLib.__Symbols.CppLib._Counter_CppData__2HA;
                *__ptr = value;
            }
        }

        public static char CHAR_RESET_VALUE { get; } = '\x00';

        public static char WCHAR_RESET_VALUE { get; } = '\0';

        public bool PubBool
        {
            get
            {
                return ((__Internal*)__Instance)->pub_bool != 0;
            }

            set
            {
                ((__Internal*)__Instance)->pub_bool = (byte) (value ? 1 : 0);
            }
        }

        public sbyte PubI8
        {
            get
            {
                return ((__Internal*)__Instance)->pub_i8;
            }

            set
            {
                ((__Internal*)__Instance)->pub_i8 = value;
            }
        }

        public short PubI16
        {
            get
            {
                return ((__Internal*)__Instance)->pub_i16;
            }

            set
            {
                ((__Internal*)__Instance)->pub_i16 = value;
            }
        }

        public int PubI32
        {
            get
            {
                return ((__Internal*)__Instance)->pub_i32;
            }

            set
            {
                ((__Internal*)__Instance)->pub_i32 = value;
            }
        }

        public long PubI64
        {
            get
            {
                return ((__Internal*)__Instance)->pub_i64;
            }

            set
            {
                ((__Internal*)__Instance)->pub_i64 = value;
            }
        }

        public float PubF32
        {
            get
            {
                return ((__Internal*)__Instance)->pub_f32;
            }

            set
            {
                ((__Internal*)__Instance)->pub_f32 = value;
            }
        }

        public double PubF64
        {
            get
            {
                return ((__Internal*)__Instance)->pub_f64;
            }

            set
            {
                ((__Internal*)__Instance)->pub_f64 = value;
            }
        }

        public bool Bool
        {
            get
            {
                var __ret = __Internal.GetBool(__Instance);
                return __ret;
            }

            set
            {
                __Internal.SetBool(__Instance, value);
            }
        }

        public sbyte Int8
        {
            get
            {
                var __ret = __Internal.GetInt8(__Instance);
                return __ret;
            }

            set
            {
                __Internal.SetInt8(__Instance, value);
            }
        }

        public short Int16
        {
            get
            {
                var __ret = __Internal.GetInt16(__Instance);
                return __ret;
            }

            set
            {
                __Internal.SetInt16(__Instance, value);
            }
        }

        public int Int32
        {
            get
            {
                var __ret = __Internal.GetInt32(__Instance);
                return __ret;
            }

            set
            {
                __Internal.SetInt32(__Instance, value);
            }
        }

        public long Int64
        {
            get
            {
                var __ret = __Internal.GetInt64(__Instance);
                return __ret;
            }

            set
            {
                __Internal.SetInt64(__Instance, value);
            }
        }

        public float Float
        {
            get
            {
                var __ret = __Internal.GetFloat(__Instance);
                return __ret;
            }

            set
            {
                __Internal.SetFloat(__Instance, value);
            }
        }

        public double Double
        {
            get
            {
                var __ret = __Internal.GetDouble(__Instance);
                return __ret;
            }

            set
            {
                __Internal.SetDouble(__Instance, value);
            }
        }
    }

    public enum Operation
    {
        Reset = 0,
        Increment = 1
    }

    public enum ScopeFlags
    {
        Bool = 1,
        Int = 2,
        Uint = 4,
        Float = 8,
        Char = 16,
        All = -1
    }

    public unsafe partial class CppOp : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("CppLib", EntryPoint = "??0CppOp@@QEAA@AEBV0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("Cpp", EntryPoint = "?Do@CppOp@@SAXAEAVCppData@@W4Operation@@W4ScopeFlags@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Do(__IntPtr data, global::CppLib.Operation op, global::CppLib.ScopeFlags scope);

            [SuppressUnmanagedCodeSecurity, DllImport("CppLib", EntryPoint = "?InScope@@YA_NW4ScopeFlags@@0@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool InScope(global::CppLib.ScopeFlags scope, global::CppLib.ScopeFlags flags);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppLib.CppOp> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppLib.CppOp>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::CppLib.CppOp managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::CppLib.CppOp managed)
        {
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CppOp __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new CppOp(native.ToPointer(), skipVTables);
        }

        internal static CppOp __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CppOp)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CppOp __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CppOp(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CppOp(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CppOp(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public CppOp()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CppLib.CppOp.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public CppOp(global::CppLib.CppOp _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CppLib.CppOp.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::CppLib.CppOp.__Internal*) __Instance) = *((global::CppLib.CppOp.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public static void Do(global::CppLib.CppData data, global::CppLib.Operation op, global::CppLib.ScopeFlags scope)
        {
            if (ReferenceEquals(data, null))
                throw new global::System.ArgumentNullException("data", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = data.__Instance;
            __Internal.Do(__arg0, op, scope);
        }

        public static bool InScope(global::CppLib.ScopeFlags scope, global::CppLib.ScopeFlags flags)
        {
            var __ret = __Internal.InScope(scope, flags);
            return __ret;
        }
    }
}
namespace CppLib.__Symbols
{
    internal class CppLib
    {
        public static IntPtr _Counter_CppData__2HA { get; }
        static CppLib()
        {
            var path = "CppLib";
            var image = CppSharp.SymbolResolver.LoadImage(ref path);
            if (image == IntPtr.Zero) throw new global::System.DllNotFoundException(path);
            _Counter_CppData__2HA = CppSharp.SymbolResolver.ResolveSymbol(image, "?Counter@CppData@@2HA");
        }
    }
}

